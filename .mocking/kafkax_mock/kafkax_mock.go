// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/SyaibanAhmadRamadhan/go-foundation-kit/broker/kafkax (interfaces: TracerPub,TracerConsume,TracerCommitMessage,PubSub)
//
// Generated by this command:
//
//	mockgen -destination=../../.mocking/kafkax_mock/kafkax_mock.go -package=kafkax_mock . TracerPub,TracerConsume,TracerCommitMessage,PubSub
//

// Package kafkax_mock is a generated GoMock package.
package kafkax_mock

import (
	context "context"
	reflect "reflect"

	kafkax "github.com/SyaibanAhmadRamadhan/go-foundation-kit/broker/kafkax"
	kafka "github.com/segmentio/kafka-go"
	gomock "go.uber.org/mock/gomock"
)

// MockTracerPub is a mock of TracerPub interface.
type MockTracerPub struct {
	ctrl     *gomock.Controller
	recorder *MockTracerPubMockRecorder
	isgomock struct{}
}

// MockTracerPubMockRecorder is the mock recorder for MockTracerPub.
type MockTracerPubMockRecorder struct {
	mock *MockTracerPub
}

// NewMockTracerPub creates a new mock instance.
func NewMockTracerPub(ctrl *gomock.Controller) *MockTracerPub {
	mock := &MockTracerPub{ctrl: ctrl}
	mock.recorder = &MockTracerPubMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTracerPub) EXPECT() *MockTracerPubMockRecorder {
	return m.recorder
}

// TracePubEnd mocks base method.
func (m *MockTracerPub) TracePubEnd(ctx context.Context, input kafkax.PubOutput, err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "TracePubEnd", ctx, input, err)
}

// TracePubEnd indicates an expected call of TracePubEnd.
func (mr *MockTracerPubMockRecorder) TracePubEnd(ctx, input, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracePubEnd", reflect.TypeOf((*MockTracerPub)(nil).TracePubEnd), ctx, input, err)
}

// TracePubStart mocks base method.
func (m *MockTracerPub) TracePubStart(ctx context.Context, msg *kafka.Message) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracePubStart", ctx, msg)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// TracePubStart indicates an expected call of TracePubStart.
func (mr *MockTracerPubMockRecorder) TracePubStart(ctx, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracePubStart", reflect.TypeOf((*MockTracerPub)(nil).TracePubStart), ctx, msg)
}

// MockTracerConsume is a mock of TracerConsume interface.
type MockTracerConsume struct {
	ctrl     *gomock.Controller
	recorder *MockTracerConsumeMockRecorder
	isgomock struct{}
}

// MockTracerConsumeMockRecorder is the mock recorder for MockTracerConsume.
type MockTracerConsumeMockRecorder struct {
	mock *MockTracerConsume
}

// NewMockTracerConsume creates a new mock instance.
func NewMockTracerConsume(ctrl *gomock.Controller) *MockTracerConsume {
	mock := &MockTracerConsume{ctrl: ctrl}
	mock.recorder = &MockTracerConsumeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTracerConsume) EXPECT() *MockTracerConsumeMockRecorder {
	return m.recorder
}

// TraceConsumeEnd mocks base method.
func (m *MockTracerConsume) TraceConsumeEnd(ctx context.Context, err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "TraceConsumeEnd", ctx, err)
}

// TraceConsumeEnd indicates an expected call of TraceConsumeEnd.
func (mr *MockTracerConsumeMockRecorder) TraceConsumeEnd(ctx, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TraceConsumeEnd", reflect.TypeOf((*MockTracerConsume)(nil).TraceConsumeEnd), ctx, err)
}

// TraceConsumeStart mocks base method.
func (m *MockTracerConsume) TraceConsumeStart(ctx context.Context, groupID string, msg *kafka.Message) context.Context {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TraceConsumeStart", ctx, groupID, msg)
	ret0, _ := ret[0].(context.Context)
	return ret0
}

// TraceConsumeStart indicates an expected call of TraceConsumeStart.
func (mr *MockTracerConsumeMockRecorder) TraceConsumeStart(ctx, groupID, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TraceConsumeStart", reflect.TypeOf((*MockTracerConsume)(nil).TraceConsumeStart), ctx, groupID, msg)
}

// MockTracerCommitMessage is a mock of TracerCommitMessage interface.
type MockTracerCommitMessage struct {
	ctrl     *gomock.Controller
	recorder *MockTracerCommitMessageMockRecorder
	isgomock struct{}
}

// MockTracerCommitMessageMockRecorder is the mock recorder for MockTracerCommitMessage.
type MockTracerCommitMessageMockRecorder struct {
	mock *MockTracerCommitMessage
}

// NewMockTracerCommitMessage creates a new mock instance.
func NewMockTracerCommitMessage(ctrl *gomock.Controller) *MockTracerCommitMessage {
	mock := &MockTracerCommitMessage{ctrl: ctrl}
	mock.recorder = &MockTracerCommitMessageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTracerCommitMessage) EXPECT() *MockTracerCommitMessageMockRecorder {
	return m.recorder
}

// TraceCommitMessagesEnd mocks base method.
func (m *MockTracerCommitMessage) TraceCommitMessagesEnd(ctx []context.Context, err error) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "TraceCommitMessagesEnd", ctx, err)
}

// TraceCommitMessagesEnd indicates an expected call of TraceCommitMessagesEnd.
func (mr *MockTracerCommitMessageMockRecorder) TraceCommitMessagesEnd(ctx, err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TraceCommitMessagesEnd", reflect.TypeOf((*MockTracerCommitMessage)(nil).TraceCommitMessagesEnd), ctx, err)
}

// TraceCommitMessagesStart mocks base method.
func (m *MockTracerCommitMessage) TraceCommitMessagesStart(ctx context.Context, groupID string, messages ...kafka.Message) []context.Context {
	m.ctrl.T.Helper()
	varargs := []any{ctx, groupID}
	for _, a := range messages {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "TraceCommitMessagesStart", varargs...)
	ret0, _ := ret[0].([]context.Context)
	return ret0
}

// TraceCommitMessagesStart indicates an expected call of TraceCommitMessagesStart.
func (mr *MockTracerCommitMessageMockRecorder) TraceCommitMessagesStart(ctx, groupID any, messages ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, groupID}, messages...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TraceCommitMessagesStart", reflect.TypeOf((*MockTracerCommitMessage)(nil).TraceCommitMessagesStart), varargs...)
}

// MockPubSub is a mock of PubSub interface.
type MockPubSub struct {
	ctrl     *gomock.Controller
	recorder *MockPubSubMockRecorder
	isgomock struct{}
}

// MockPubSubMockRecorder is the mock recorder for MockPubSub.
type MockPubSubMockRecorder struct {
	mock *MockPubSub
}

// NewMockPubSub creates a new mock instance.
func NewMockPubSub(ctrl *gomock.Controller) *MockPubSub {
	mock := &MockPubSub{ctrl: ctrl}
	mock.recorder = &MockPubSubMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPubSub) EXPECT() *MockPubSubMockRecorder {
	return m.recorder
}

// Publish mocks base method.
func (m *MockPubSub) Publish(ctx context.Context, input kafkax.PubInput) (kafkax.PubOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", ctx, input)
	ret0, _ := ret[0].(kafkax.PubOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Publish indicates an expected call of Publish.
func (mr *MockPubSubMockRecorder) Publish(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockPubSub)(nil).Publish), ctx, input)
}

// Subscribe mocks base method.
func (m *MockPubSub) Subscribe(ctx context.Context, input kafkax.SubInput) (kafkax.SubOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, input)
	ret0, _ := ret[0].(kafkax.SubOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockPubSubMockRecorder) Subscribe(ctx, input any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockPubSub)(nil).Subscribe), ctx, input)
}
