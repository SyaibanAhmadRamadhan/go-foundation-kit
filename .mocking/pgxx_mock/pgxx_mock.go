// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/SyaibanAhmadRamadhan/go-foundation-kit/databases/pgxx (interfaces: RDBMS,ReadQuery,WriterCommand,Tx)
//
// Generated by this command:
//
//	mockgen -destination=../../.mocking/pgxx_mock/pgxx_mock.go -package=pgxx_mock . RDBMS,ReadQuery,WriterCommand,Tx
//

// Package pgxx_mock is a generated GoMock package.
package pgxx_mock

import (
	context "context"
	reflect "reflect"

	squirrel "github.com/Masterminds/squirrel"
	pgxx "github.com/SyaibanAhmadRamadhan/go-foundation-kit/databases/pgxx"
	primitive "github.com/SyaibanAhmadRamadhan/go-foundation-kit/utils/primitive"
	pgx "github.com/jackc/pgx/v5"
	pgconn "github.com/jackc/pgx/v5/pgconn"
	gomock "go.uber.org/mock/gomock"
)

// MockRDBMS is a mock of RDBMS interface.
type MockRDBMS struct {
	ctrl     *gomock.Controller
	recorder *MockRDBMSMockRecorder
	isgomock struct{}
}

// MockRDBMSMockRecorder is the mock recorder for MockRDBMS.
type MockRDBMSMockRecorder struct {
	mock *MockRDBMS
}

// NewMockRDBMS creates a new mock instance.
func NewMockRDBMS(ctrl *gomock.Controller) *MockRDBMS {
	mock := &MockRDBMS{ctrl: ctrl}
	mock.recorder = &MockRDBMSMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRDBMS) EXPECT() *MockRDBMSMockRecorder {
	return m.recorder
}

// Exec mocks base method.
func (m *MockRDBMS) Exec(ctx context.Context, sql string, arguments ...any) (pgconn.CommandTag, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql}
	for _, a := range arguments {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Exec", varargs...)
	ret0, _ := ret[0].(pgconn.CommandTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exec indicates an expected call of Exec.
func (mr *MockRDBMSMockRecorder) Exec(ctx, sql any, arguments ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql}, arguments...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockRDBMS)(nil).Exec), varargs...)
}

// ExecSq mocks base method.
func (m *MockRDBMS) ExecSq(ctx context.Context, query squirrel.Sqlizer) (pgconn.CommandTag, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecSq", ctx, query)
	ret0, _ := ret[0].(pgconn.CommandTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecSq indicates an expected call of ExecSq.
func (mr *MockRDBMSMockRecorder) ExecSq(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecSq", reflect.TypeOf((*MockRDBMS)(nil).ExecSq), ctx, query)
}

// Query mocks base method.
func (m *MockRDBMS) Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(pgx.Rows)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query.
func (mr *MockRDBMSMockRecorder) Query(ctx, sql any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockRDBMS)(nil).Query), varargs...)
}

// QueryRow mocks base method.
func (m *MockRDBMS) QueryRow(ctx context.Context, sql string, args ...any) pgx.Row {
	m.ctrl.T.Helper()
	varargs := []any{ctx, sql}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "QueryRow", varargs...)
	ret0, _ := ret[0].(pgx.Row)
	return ret0
}

// QueryRow indicates an expected call of QueryRow.
func (mr *MockRDBMSMockRecorder) QueryRow(ctx, sql any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, sql}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRow", reflect.TypeOf((*MockRDBMS)(nil).QueryRow), varargs...)
}

// QueryRowSq mocks base method.
func (m *MockRDBMS) QueryRowSq(ctx context.Context, query squirrel.Sqlizer) (pgx.Row, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryRowSq", ctx, query)
	ret0, _ := ret[0].(pgx.Row)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryRowSq indicates an expected call of QueryRowSq.
func (mr *MockRDBMSMockRecorder) QueryRowSq(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowSq", reflect.TypeOf((*MockRDBMS)(nil).QueryRowSq), ctx, query)
}

// QuerySq mocks base method.
func (m *MockRDBMS) QuerySq(ctx context.Context, query squirrel.Sqlizer, fn func(pgx.Rows) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QuerySq", ctx, query, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// QuerySq indicates an expected call of QuerySq.
func (mr *MockRDBMSMockRecorder) QuerySq(ctx, query, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySq", reflect.TypeOf((*MockRDBMS)(nil).QuerySq), ctx, query, fn)
}

// QuerySqPagination mocks base method.
func (m *MockRDBMS) QuerySqPagination(ctx context.Context, countQuery, query squirrel.SelectBuilder, paginationInput primitive.PaginationInput, fn func(pgx.Rows) error) (primitive.PaginationOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QuerySqPagination", ctx, countQuery, query, paginationInput, fn)
	ret0, _ := ret[0].(primitive.PaginationOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QuerySqPagination indicates an expected call of QuerySqPagination.
func (mr *MockRDBMSMockRecorder) QuerySqPagination(ctx, countQuery, query, paginationInput, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySqPagination", reflect.TypeOf((*MockRDBMS)(nil).QuerySqPagination), ctx, countQuery, query, paginationInput, fn)
}

// MockReadQuery is a mock of ReadQuery interface.
type MockReadQuery struct {
	ctrl     *gomock.Controller
	recorder *MockReadQueryMockRecorder
	isgomock struct{}
}

// MockReadQueryMockRecorder is the mock recorder for MockReadQuery.
type MockReadQueryMockRecorder struct {
	mock *MockReadQuery
}

// NewMockReadQuery creates a new mock instance.
func NewMockReadQuery(ctrl *gomock.Controller) *MockReadQuery {
	mock := &MockReadQuery{ctrl: ctrl}
	mock.recorder = &MockReadQueryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReadQuery) EXPECT() *MockReadQueryMockRecorder {
	return m.recorder
}

// QueryRowSq mocks base method.
func (m *MockReadQuery) QueryRowSq(ctx context.Context, query squirrel.Sqlizer) (pgx.Row, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueryRowSq", ctx, query)
	ret0, _ := ret[0].(pgx.Row)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueryRowSq indicates an expected call of QueryRowSq.
func (mr *MockReadQueryMockRecorder) QueryRowSq(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryRowSq", reflect.TypeOf((*MockReadQuery)(nil).QueryRowSq), ctx, query)
}

// QuerySq mocks base method.
func (m *MockReadQuery) QuerySq(ctx context.Context, query squirrel.Sqlizer, fn func(pgx.Rows) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QuerySq", ctx, query, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// QuerySq indicates an expected call of QuerySq.
func (mr *MockReadQueryMockRecorder) QuerySq(ctx, query, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySq", reflect.TypeOf((*MockReadQuery)(nil).QuerySq), ctx, query, fn)
}

// QuerySqPagination mocks base method.
func (m *MockReadQuery) QuerySqPagination(ctx context.Context, countQuery, query squirrel.SelectBuilder, paginationInput primitive.PaginationInput, fn func(pgx.Rows) error) (primitive.PaginationOutput, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QuerySqPagination", ctx, countQuery, query, paginationInput, fn)
	ret0, _ := ret[0].(primitive.PaginationOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QuerySqPagination indicates an expected call of QuerySqPagination.
func (mr *MockReadQueryMockRecorder) QuerySqPagination(ctx, countQuery, query, paginationInput, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QuerySqPagination", reflect.TypeOf((*MockReadQuery)(nil).QuerySqPagination), ctx, countQuery, query, paginationInput, fn)
}

// MockWriterCommand is a mock of WriterCommand interface.
type MockWriterCommand struct {
	ctrl     *gomock.Controller
	recorder *MockWriterCommandMockRecorder
	isgomock struct{}
}

// MockWriterCommandMockRecorder is the mock recorder for MockWriterCommand.
type MockWriterCommandMockRecorder struct {
	mock *MockWriterCommand
}

// NewMockWriterCommand creates a new mock instance.
func NewMockWriterCommand(ctrl *gomock.Controller) *MockWriterCommand {
	mock := &MockWriterCommand{ctrl: ctrl}
	mock.recorder = &MockWriterCommandMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWriterCommand) EXPECT() *MockWriterCommandMockRecorder {
	return m.recorder
}

// ExecSq mocks base method.
func (m *MockWriterCommand) ExecSq(ctx context.Context, query squirrel.Sqlizer) (pgconn.CommandTag, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExecSq", ctx, query)
	ret0, _ := ret[0].(pgconn.CommandTag)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ExecSq indicates an expected call of ExecSq.
func (mr *MockWriterCommandMockRecorder) ExecSq(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecSq", reflect.TypeOf((*MockWriterCommand)(nil).ExecSq), ctx, query)
}

// MockTx is a mock of Tx interface.
type MockTx struct {
	ctrl     *gomock.Controller
	recorder *MockTxMockRecorder
	isgomock struct{}
}

// MockTxMockRecorder is the mock recorder for MockTx.
type MockTxMockRecorder struct {
	mock *MockTx
}

// NewMockTx creates a new mock instance.
func NewMockTx(ctrl *gomock.Controller) *MockTx {
	mock := &MockTx{ctrl: ctrl}
	mock.recorder = &MockTxMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTx) EXPECT() *MockTxMockRecorder {
	return m.recorder
}

// DoTx mocks base method.
func (m *MockTx) DoTx(ctx context.Context, opt pgx.TxOptions, fn func(pgxx.RDBMS) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTx", ctx, opt, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTx indicates an expected call of DoTx.
func (mr *MockTxMockRecorder) DoTx(ctx, opt, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTx", reflect.TypeOf((*MockTx)(nil).DoTx), ctx, opt, fn)
}

// DoTxContext mocks base method.
func (m *MockTx) DoTxContext(ctx context.Context, opt pgx.TxOptions, fn func(context.Context, pgxx.RDBMS) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DoTxContext", ctx, opt, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxContext indicates an expected call of DoTxContext.
func (mr *MockTxMockRecorder) DoTxContext(ctx, opt, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxContext", reflect.TypeOf((*MockTx)(nil).DoTxContext), ctx, opt, fn)
}
